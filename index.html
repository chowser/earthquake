<!--

https://bl.ocks.org/mbostock/4699541
https://bl.ocks.org/mbostock/4090848
https://medium.com/@mbostock/command-line-cartography-part-1-897aa8f8ca2c
https://raw.githubusercontent.com/deldersveld/topojson/master/countries/us-states/OK-40-oklahoma-counties.json
https://bl.ocks.org/mbostock/raw/5663666/
http://bl.ocks.org/darrenjaworski/5874214 ***
https://bl.ocks.org/gka/f2aabf4a516e16a5190f25fd1923406f ***
https://beta.observablehq.com/@mbostock/d3-choropleth
https://beta.observablehq.com/@mbostock/d3-bubble-map
http://duspviz.mit.edu/d3-workshop/mapping-data-with-d3/
http://bl.ocks.org/phil-pedruco/7745589 ***
https://anthonyskelton.com/2016/d3-js-earthquake-visualizations/
https://hackernoon.com/d3-js-and-google-maps-api-in-10-easy-steps-4f258323525b
https://bost.ocks.org/mike/leaflet/
http://bl.ocks.org/d3noob/9267535
http://datamaps.github.io/
http://eric.clst.org/tech/usgeojson/

uses topojson instead of geojson for better performance and ease of use:
https://bl.ocks.org/mbostock/5545680
topojson data: https://github.com/topojson/us-atlas

tool to find coordinates:
https://mynasadata.larc.nasa.gov/latitudelongitude-finder/

us-atlas already projected:
https://stackoverflow.com/questions/44507572/setting-projection-of-d3-geopath-not-working-as-documented

http://pnavarrc.github.io/talk-d3-charts/earthquake.html

download cencus tracts:
https://www.census.gov/cgi-bin/geo/shapefiles/index.php
-->
<!doctype html>

<head>
   <script src="https://d3js.org/d3.v4.min.js"></script>
   <script src="https://d3js.org/topojson.v2.min.js"></script>
   <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
   <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

   <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
   <style>
      #custom-handle {
        width: 3em
        height: 1.6em
        top: 50%
        margin-top: -.8em
        text-align: center
        line-height: 1.6em
      }
   </style>
</head>

<body>
   <center>
      <div id="slider">
        <div id="custom-handle" class="ui-slider-handle"></div>
        <br/>
        <div>
           <button  id="btnDraw" type="button">Create Map</button>
        </div>
      </div>
      <div id="chart"></div>
   </center>
</body>

<!-- create slider -->
<script type="text/javascript">
$( function() {
  var handle = $("#custom-handle")

  $("#slider").slider({
    min: 1900,
    max: 2018,
    create: function() {
      handle.text( $(this).slider("value"))
    },
    slide: function(event, ui) {
      handle.text(ui.value)
    }
  })

  $("#btnDraw").click(function(){
     drawEarthquakes($("#slider").slider("value"))
  })
})
</script>

<!-- create chart -->
<script type="text/javascript">
// note: map points are formatted as [longitude,latitude]

// global variables
var svgWidth  = 960
var svgHeight = 500
var padding   = 20
var state, earthquakes, wells, point, magnitude, startYear, filteredEarthquakes, earthquakeCircles, wellCircles

// formatter for date objects
var formatDate = d3.timeFormat("%Y")

// color scale for earthquakes
var color = d3.scaleLinear()
              .domain([3, 6])
              .range(["yellow", "red"])

// create SVG element
var svg = d3.select("#chart")
            .append("svg")
            .attr("width", svgWidth)
            .attr("height", svgHeight)
            .attr("fill","white")

d3.queue()
.defer(d3.json, 'data/ok.json')
.defer(d3.csv, 'data/ok_earthquakes.csv')
.defer(d3.csv, 'data/injection_wells.csv')
.await(dataLoaded)

function dataLoaded(error, a, b, c) {
   state       = a
   earthquakes = b
   wells       = c
   // convert origin time from datetime to year using formatDate()
   // we only need the year for filtering
   earthquakes = earthquakes.map(function(d){
      d.origintime = formatDate(new Date(d.origintime))
      return d
   })

   // filter earthquakes with magnitude >= 3
   // this is the threshold in which earthquakes are felt
   filteredEarthquakes = earthquakes.filter(function(d){ return +d.prefmag >= 3 })
   console.log(filteredEarthquakes)

   // calculate boundaries (for later use)
   var bounds = state.bbox
   var longitudeLeft  = bounds[0]
   var latitudeBottom = bounds[1]
   var longitudeRight = bounds[2]
   var latitudeTop    = bounds[3]

   // define projection
   projection = d3.geoMercator()
                   .fitSize([svgWidth,svgHeight],state)

   // define path generator
   var path = d3.geoPath()
                .projection(projection)

   // draw state (bind data and create one path per GeoJSON feature)
   svg.selectAll("path")
      .data(state.features)
      .enter()
      .append("path")
      .attr("d", path)
      .attr("stroke","black")
   } // end dataLoaded()

function drawEarthquakes(startYear) {
   // sort earthquakes
   // earthquakes = earthquakes.sort(function(a,b){ d3.ascending(+a.prefmag,+b.prefmag) }))

   // filter earthquakes from 2018
   filteredEarthquakes = earthquakes.filter(function(d){
      return +d.origintime >= startYear
   })
   console.log(filteredEarthquakes)

   //sortedEarthquakes = earthquakes.sort(function(a,b){ d3.descending(+a.prefmag,+b.prefmag) })
   //console.log(earthquakes) })

   // setup the chart
   earthquakeCircles = svg.append("g")
   .data(filteredEarthquakes)
   .enter()

   earthquakeCircles.append("circle")
      // +d.LONG converts string to integer
      .attr("cx", function(d){
                     // preceding + converts string to int
                     return projection([+d.longitude,+d.latitude])[0] })
      // +d.LAT converts string to integer
      .attr("cy", function(d){
                     // preceding + converts string to int
                     return projection([+d.longitude,+d.latitude])[1] })
      .attr("r", function(d){
                    // only return earthquakes that can be felt
                    // see https://earthquake.usgs.gov/learn/topics/mag_vs_int.php
                    if(+d.prefmag >= 3){
                       // preceding + converts string to int

                       // scale magnitudes exponentially to provide
                       // noticeable differentiation
                       return Math.pow(+d.prefmag,2.2) }
                    else{ return 0 } })
      .attr("stroke", "gray")
      .attr("fill", function(d){ return color(+d.prefmag) })

   wellCircles = svg.append("g")
     .data(wells)
     .enter()

   wellCircles.append("circle")
     .attr("cx", function(d) {
                    // preceding + converts string to int
                    point = [+d.LONG,+d.LAT]
                    return projection(point)[0]
                 })
     .attr("cy", function(d) {
                    // preceding + converts string to int
                    point = [+d.LONG,+d.LAT]
                    return projection(point)[1]
                 })
     .attr("r", "1px")
     .attr("fill", "green")
   } // end drawEarthquakes()
</script>
</html>
