<!--

https://bl.ocks.org/mbostock/4699541
https://bl.ocks.org/mbostock/4090848
https://medium.com/@mbostock/command-line-cartography-part-1-897aa8f8ca2c
https://raw.githubusercontent.com/deldersveld/topojson/master/countries/us-states/OK-40-oklahoma-counties.json
https://bl.ocks.org/mbostock/raw/5663666/
http://bl.ocks.org/darrenjaworski/5874214 ***
https://bl.ocks.org/gka/f2aabf4a516e16a5190f25fd1923406f ***
https://beta.observablehq.com/@mbostock/d3-choropleth
https://beta.observablehq.com/@mbostock/d3-bubble-map
http://duspviz.mit.edu/d3-workshop/mapping-data-with-d3/
http://bl.ocks.org/phil-pedruco/7745589 ***
https://anthonyskelton.com/2016/d3-js-earthquake-visualizations/
https://hackernoon.com/d3-js-and-google-maps-api-in-10-easy-steps-4f258323525b
https://bost.ocks.org/mike/leaflet/
http://bl.ocks.org/d3noob/9267535
http://datamaps.github.io/
http://eric.clst.org/tech/usgeojson/

uses topojson instead of geojson for better performance and ease of use:
https://bl.ocks.org/mbostock/5545680
topojson data: https://github.com/topojson/us-atlas

tool to find coordinates:
https://mynasadata.larc.nasa.gov/latitudelongitude-finder/

us-atlas already projected:
https://stackoverflow.com/questions/44507572/setting-projection-of-d3-geopath-not-working-as-documented

http://pnavarrc.github.io/talk-d3-charts/earthquake.html

download cencus tracts:
https://www.census.gov/cgi-bin/geo/shapefiles/index.php
-->
<!doctype html>

<head>
   <script src="https://d3js.org/d3.v4.min.js"></script>
   <script src="https://d3js.org/topojson.v2.min.js"></script>
</head>

<body>
   <center>
      <div id="chart"></div>
   </center>
</body>

<script type="text/javascript">
// note: map points are formatted as [longitude,latitude]

// global variables
var svgWidth  = 960
var svgHeight = 500
var padding   = 20
var point, magnitude
var formatDate = d3.timeFormat("%Y")

// color scale for earthquakes
var color = d3.scaleLinear()
              .domain([3, 6])
              .range(["yellow", "red"]);

/*
// opacity scale for earthquakes [doesn't look that great]
var opacity = d3.scalePow()
                .exponent(2)
                .domain([0,10])
                .range([0.3,0.8])
*/

// create SVG element
var svg = d3.select("#chart")
            .append("svg")
            .attr("width", svgWidth)
            .attr("height", svgHeight)
            .attr("fill","white")

// preload data with d3.queue() so map isn't generated before data is loaded
d3.queue()
.defer(d3.json, 'data/ok.json')
.defer(d3.csv, 'data/ok_earthquakes.csv')
.defer(d3.csv, 'data/injection_wells.csv')
.await(dataLoaded)

function dataLoaded(error, state, earthquakes, wells) {
console.log(state)
console.log(state.features)
console.log("Earthquakes Original\n" + earthquakes)
// console.log("Earthquakes Sorted\n" + earthquakes.sort(function(a,b){ d3.ascending(+a.prefmag,+b.prefmag) }))
// console.log("Earthquakes Filtered\n" + earthquakes.filter(function(d){ return +d.prefmag >= 3 }))

console.log("Earthquake Year\n" + formatDate(new Date(earthquakes[0].origintime)))

// calculate boundaries (for later use)
var bounds = state.bbox
var longitudeLeft  = bounds[0]
var latitudeBottom = bounds[1]
var longitudeRight = bounds[2]
var latitudeTop    = bounds[3]

// define projection
projection = d3.geoMercator()
                .fitSize([svgWidth,svgHeight],state)

console.log("Projection\n" + projection)

// define path generator
var path = d3.geoPath()
             .projection(projection)

// draw state (bind data and create one path per GeoJSON feature)
svg.selectAll("path")
   .data(state.features)
   .enter()
   .append("path")
   .attr("d", path)
   .attr("stroke","black")

// draw earthquakes
svg.selectAll(".earthquake")
   .data(earthquakes)
         //.filter(function(d){ return +d.prefmag >= 3 })
         //.sort(function(a,b){ d3.descending(+a.prefmag,+b.prefmag) })
            //console.log(earthquakes) })
   .enter()
   .append("circle")
   // +d.LONG converts string to integer
   .attr("cx", function(d){
                  // preceding + converts string to int
                  return projection([+d.longitude,+d.latitude])[0] })
   // +d.LAT converts string to integer
   .attr("cy", function(d){
                  // preceding + converts string to int
                  return projection([+d.longitude,+d.latitude])[1] })
   .attr("r", function(d){
                 // only return earthquakes that can be felt
                 // see https://earthquake.usgs.gov/learn/topics/mag_vs_int.php
                 if(+d.prefmag >= 3){
                    // preceding + converts string to int
                    // return Math.log(+d.prefmag*2)*10 this sucks
                    return Math.pow(+d.prefmag,2.2) }
                 else{ return 0 } })
   .attr("stroke", "gray")
   .attr("fill", function(d){
                    return color(+d.prefmag) })
/*
   .attr("opacity", function(d){
                       return opacity(+d.prefmag) })
                       */
   console.log("Done with earthquakes.")

   // draw wells
   svg.selectAll(".well")
     .data(wells)
     .enter()
     .append("circle")
     .attr("cx", function(d) {
                    // preceding + converts string to int
                    point = [+d.LONG,+d.LAT]
                    return projection(point)[0]
                 })
     .attr("cy", function(d) {
                    // preceding + converts string to int
                    point = [+d.LONG,+d.LAT]
                    return projection(point)[1]
                 })
     .attr("r", "1px")
     .attr("fill", "green")
     console.log("Done with earthquakes.")
} // end dataLoaded()
</script>
</html>
